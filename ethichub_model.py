# -*- coding: utf-8 -*-
"""EthicHub  Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JF6DMWzfkUNYaYcxql82xhaRRxrubeF8
"""



# cadCAD configuration modules
from cadCAD.configuration.utils import config_sim
from cadCAD.configuration import Experiment

# cadCAD simulation engine modules
from cadCAD.engine import ExecutionMode, ExecutionContext
from cadCAD.engine import Executor

#dataclass library
from dataclasses import dataclass , field

import itertools

"""- state variables and system parameters"""

# Model State & Params
initial_state = {
   'originators': {'rqst':0},
   'stakers':{} ,
   'comp_reserve_ETHIX':50_000_000, #compensation reserve ETH
   'liquidity_pool_DAI':1_000,#DAI
   'originator_credit_line_DAI': {'loan_amount':0}, #DAI
   'orig_pool_ETHIX':0,       #originator pool => ETHIX -> collateral_pool_ETHIX           
   'ethix_price': 1           # = ETHIX/DAI
}

params = {
    'alpha':[1],        #target utilization ratio
    'gamma': [0.2],     #originator skin
    'theta': [0.2],     #auditor skin
    'eta' :[0.2],       #backer skin
    'tu': [50],        #Originator stake lock time
    'dao_fee':[0.00],   
    'stakers_fee':[0.05], 
    'tm':[30]           #loan maturity
    }

"""- agent classes"""

#agent class
id_iter = itertools.count()
@dataclass
class Agent:
  ID: str = field(init=False)
  assets: dict = field (init=False, default_factory=dict)
  
  def __post_init__(self):
    self.ID = str(next(id_iter)) #creates a unique ID for each agent object

  def get_asset(self,tipo = str, asset = object):
      self.assets[tipo] = asset
           
@dataclass
class originator(Agent): 
  wallet:dict  
  cl: bool = False
  defaults: dict = field ( default_factory=dict)

  def loan_request(self,rqst):
    self.get_asset('request',rqst)

  def borrow(self,borrow):
    self.get_asset('borrow',borrow)
    self.get_asset('debt',borrow.loan)
    self.wallet['DAI'] += borrow.loan
    print(f'originator {self.ID} taking {borrow.loan} DAI from credit line')
    
  def stake(self,stake):#MUDAR
    if self.wallet['ETHIX'] - stake.stake > 0:
      self.get_asset('stake',stake.stake)
      self.wallet['ETHIX'] -= stake.stake
      return True
    else:
      return False

  def payment(self,payment):
    if self.wallet['DAI'] > payment:
      if self.assets['debt']:
        if self.assets['debt'] != 0:
          self.wallet['DAI'] -= payment
          self.assets['debt'] -= payment
          a = self.assets['debt']
        else:
          self.assets.pop('debt')
          print('originator',self.ID,':debt settled')
    else:
      print("originator doesn't have enough DAI")

  def default(self,loan,timestep):
    self.defaults.update({str(timestep):loan.loan/10})
    
@dataclass
class staker(Agent):
  wallet: dict

  def stake(self,stake):
    if self.wallet['ETHIX'] - stake.stake > 0:
      self.get_asset('stake',stake)
      self.wallet['ETHIX'] -= stake.stake
      return True
    else:
       return False
    
  def investiment_return(self,invest_return):
    self.wallet['ETHIX'] += invest_return

@dataclass
class l_request:
  t0: int
  t0_ETHIX_price:float
  loan_request: float = 50.0 #DAI
  
@dataclass
class loan:
  loan:float
  t0:int
  tm:int  #loan maturity
  ID:str = field(init=False)
  t0_ETHIX_price:float
  installments:dict = field (init=False, default_factory=dict)
  liq : bool = False
  paid:bool = False
  
  def __post_init__(self):
    self.ID = f'l_{str(next(id_iter))}'

  def liquidated(self):
    self.liq = True

  def pay(self,payment,t):
    if self.installments:
      if sum(self.installments.values()) < self.loan:
        self.installments[str(t)] = payment
      else:
        self.paid = True
        print(f'loan = {self.ID} paid!')

    
@dataclass
class stake: 
  stake:float
  t0:int
  t0_ETHIX_price:float


@dataclass
class credit_line:
  #originatorID:str
  loans:dict
  coll: dict

"""- auxiliar functions"""

import numpy as np
def coinFlip(p):    
    #perform the binomial distribution (returns 0 or 1)    
    result = np.random.binomial(1,p) 

    return result

def payment_behaviour(t,t0,tm):
  if t != round((t0+tm)/2):
    if t>t0 and t<=t0+tm:
      return 'pay'
    elif t<t0:
      return 'no debt to pay'
  else:
    return "don't pay"

"""- Policy functions"""

#generates originators and stakers
def p_agents(params, step, history, prev_state):
  timestep = prev_state['timestep']
  ETHIX_price = prev_state['ethix_price']
  orig = None
  stk = None
  staked_amount = 0

  if timestep == 5 or timestep == 20:
    orig = originator({'ETHIX':200,'DAI':10})
    #originator staking
    staking = stake(100,timestep,ETHIX_price) #ETHIX
    orig.stake(staking)
    staked_amount += staking.stake
    #print(f'originagor {orig.ID} staking now')
      
  if coinFlip(.2) == 1:
    stk = staker({'ETHIX':200})
    #staker staking
    staking = stake(100,timestep,ETHIX_price) #ETHIX
    stk.stake(staking)
    staked_amount += staking.stake
    #print(f'staker {stk.ID} staking now')
       
  return {'originators': orig,'stakers':stk,'ETHIX_flow':staked_amount}

#collateralization and borrow process
def p_credit_lines(params, step, history, prev_state):
    originators = prev_state['originators']
    stakers = prev_state['stakers']
    orig_pool = prev_state['orig_pool_ETHIX']
    credit_lines = {}
    ethix_price = prev_state['ethix_price']
    timestep = prev_state['timestep']
      
    if timestep == 100:
        print('stakers: ',stakers)
        print('originators: ',originators)

    #creating credit line
    for orig in originators.values():
      if isinstance(orig,originator):
        if not orig.cl:
            coll_amount = orig.assets['stake']
            if coll_amount > 0:
              cred_line = credit_line({},{'status':False,'enabled_amount':coll_amount})#in ethix
              orig.cl = True
              credit_lines[orig.ID] = cred_line
              print(f'credit line created for originator {orig.ID}')

        if timestep == 6 or timestep == 21:
            if 'request' not in orig.assets:
              print(f'originator {orig.ID} requesting a loan...')
              l = l_request(timestep,ethix_price) #in DAI
              orig.loan_request(l)
              originators['rqst'] += l.loan_request

    return {'credit_lines':credit_lines,'originators':originators}

def p_borrows(params, step, history, prev_state):
  originators = prev_state['originators']
  orig_pool = prev_state['orig_pool_ETHIX']
  crdt_lns = prev_state['originator_credit_line_DAI']
  ethix_price = prev_state['ethix_price']
  timestep = prev_state['timestep']
  DAI_flow = 0
  comp = 0
  tm = params['tm']
   

  if crdt_lns['loan_amount'] > orig_pool*ethix_price:
    print('total loan amount uncollateralized...compensating...')
    comp = crdt_lns['loan_amount'] - orig_pool*ethix_price
  else:
    if originators['rqst'] + crdt_lns['loan_amount'] <= orig_pool * ethix_price:
      for orig in originators.values():
        if isinstance(orig,originator):
          if 'request' in orig.assets:
              enbld_amnt = crdt_lns[orig.ID].coll['enabled_amount']
              crdt_line = crdt_lns[orig.ID]
              rqst = orig.assets['request']
              if rqst.loan_request <= enbld_amnt*ethix_price:
                print(f'originator {orig.ID}, borrowing now..')
                l = loan(loan = rqst.loan_request,t0= timestep,tm = tm,t0_ETHIX_price = ethix_price)
                orig.borrow(l)
                orig.assets.pop('request')
                crdt_line.loans[l.ID] = l
                originators['rqst'] -= l.loan
                crdt_lns['loan_amount'] += l.loan
                DAI_flow +=l.loan
              else:
                print(f'loan denied for originator {orig.ID}')
    else:
      print('not enough collateral...')
  if DAI_flow >0:
    print(f'taking {DAI_flow} DAI from liq pool at timestep = {timestep}')
  return {'originators': originators, 'credit_lines': crdt_lns, 'DAI_flow':-DAI_flow, 'ETHIX_flow':comp/ethix_price}

def p_payments(params, step, history, prev_state):
  originators = prev_state['originators']
  stakers = prev_state['stakers']
  timestep = prev_state['timestep']
  crdt_lns = prev_state['originator_credit_line_DAI']
  ethix_price = prev_state['ethix_price']
  stakers_fee = params['stakers_fee']
  comp = 0
  DAI_flow = 0

  if crdt_lns and originators: 
    for orig in originators.values():
      if isinstance(orig,originator):
        cl = crdt_lns[orig.ID]
        for l in cl.loans.values():
          if isinstance(l,loan):
            if timestep <= l.t0+l.tm:
              trggr = payment_behaviour(timestep,l.t0,l.tm)
              if trggr == 'pay':
                if not l.paid:
                  if orig.assets['debt']:
                    orig.payment(l.loan/10)
                    l.pay(l.loan/10,timestep)
                    DAI_flow += l.loan/10

              elif trggr == "don't pay":
                if not l.paid:
                  if orig.assets['debt']:
                    print(f'time of default = {timestep}')
                    l.pay(l.loan/10,timestep)
                    orig.default(l,timestep)
                    comp +=l.loan/10/ethix_price
                    DAI_flow += l.loan/10

            else:
              if not l.paid:
                if orig.assets['debt']:
                  print(f'default...maturity..{timestep}')
                  payment = l.loan - sum(l.installments.values()) 
                  l.pay(payment,timestep)
                  orig.default(l,timestep)
                  comp +=payment/ethix_price #DAI 
                  DAI_flow += payment

                  
  fees = 0
  if stakers:
    for stk in stakers.values():
      if stk.assets['stake']:
        if stk.assets['stake'].t0 > timestep:
          ret = stakers_fee*stk.assets['stake'].stake
          staker.investiment_return(ret)
          print(f'staker {stk.ID} receiving a return on investiment')
          fees +=ret
  
  if DAI_flow >0:
    print(f'returning {DAI_flow} DAI from liq pool at timestep = {timestep}')

  return {'originators':originators,'stakers':stakers,'DAI_flow':DAI_flow, 'ETHIX_flow':comp+fees}
      
def p_ethix_price(params, step, history, prev_state):
  #ETHIX/DAI
   return {'ethix_price':1}

"""- State update functions"""

def s_ethix_price(params, step, _3, state, policy_input):
  ethix_price = policy_input['ethix_price']  
  return 'ethix_price', ethix_price

def s_originators(params, step, _3, state, policy_input):  
  originator = policy_input['originators']
  originator_dict = state['originators']
  if type(originator) is dict:
    return 'originators', originator_dict

  else:
      if originator is not None:
        originator_dict[originator.ID] = originator
      return 'originators', originator_dict

def s_stakers(params, step, _3, state, policy_input):
  staker = policy_input['stakers']
  stakers_dict = state['stakers']
  
  if type(staker) is dict:
    return 'stakers', stakers_dict
  else:
    if staker is not None:       
      stakers_dict[staker.ID] = staker

    return 'stakers', stakers_dict

def s_originator_credit_line(params, step, _3, state, policy_input):
  pool = state['originator_credit_line_DAI']
  crdt_lns = policy_input['credit_lines']
  if crdt_lns:
    for cl in crdt_lns:
      pool.update(crdt_lns)

  return 'originator_credit_line_DAI',pool

def s_comp_reserve(params, step, _3, state, policy_input):
  comp_reserve = state['comp_reserve_ETHIX']
  comp = policy_input['ETHIX_flow']
  if policy_input['ETHIX_flow'] > 0:
    print('compensating...=',policy_input['ETHIX_flow'])
  comp_reserve -= comp

  if state['timestep'] == 99:
    comp_reserve -= 1
    print('taking 1 from comp reserve...')

  return 'comp_reserve_ETHIX', comp_reserve

def s_liq_pool(params, step, _3, state, policy_input): 
  liq_pool = state['liquidity_pool_DAI'] 
  liq_pool += policy_input['DAI_flow']
  if policy_input['DAI_flow'] < 0:
    print('liq pool missing DAI...') 
  elif policy_input['DAI_flow'] < 0:
    print('liq pool gaining DAI...') 

  return 'liquidity_pool_DAI', liq_pool

  
def s_orig_pool(params, step, _3, state, policy_input):
  orig_pool = state['orig_pool_ETHIX']
  orig_pool += policy_input['ETHIX_flow'] 
  
  return 'orig_pool_ETHIX', orig_pool

"""- Partial state update blocks

"""

partial_state_update_blocks = [
    
    {
        'policies': {
                'ethix_price':p_ethix_price,
                'agents':p_agents 
        }, 
        
        'variables': {
             'ethix_price':s_ethix_price,
             'originators':s_originators,
             'stakers':s_stakers,
             'orig_pool_ETHIX': s_orig_pool,

             
        }
    },
     
    {
        'policies': {
                'credit_lines':p_credit_lines
                             
        }, 
        
    'variables': {
             'originator_credit_line_DAI': s_originator_credit_line,
             'originators':s_originators,

            
        }
    },
     
    {
        'policies': {
                'borrows':p_borrows
                             
        }, 
        
    'variables': {
              'originator_credit_line_DAI':s_originator_credit_line,
              'liquidity_pool_DAI':s_liq_pool,
              'originators':s_originators,
              'orig_pool_ETHIX': s_orig_pool,
              'comp_reserve_ETHIX':s_comp_reserve
              
        }
    },
     
    {
        'policies': {
                'payments':p_payments
                             
        }, 
        
    'variables': {
              'liquidity_pool_DAI':s_liq_pool,
              'originators':s_originators,
              'stakers':s_stakers,
              'orig_pool_ETHIX': s_orig_pool,
             'comp_reserve_ETHIX':s_comp_reserve
              
        }
    }
]